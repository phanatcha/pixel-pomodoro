#include <Keypad.h>
#include <Adafruit_GFX.h>
#include <FastLED.h>
#include <FastLED_NeoMatrix.h>
#include <avr/pgmspace.h>
#include <Framebuffer_GFX.h>

// --- Pin Definitions ---
#define BUZZER_PIN 11
#define JOY_BUTTON_PIN 12
#define PIN_MATRIX 13
#define JOY_X_PIN A0
#define JOY_Y_PIN A1
#define CARTOON_PAGE 0
#define POMODORO_PAGE 1
#define NUM_LEDS 256

// --- LED Matrix Setup ---
// Define the array of leds
CRGB leds[NUM_LEDS];

// Setup FastLED_NeoMatrix - 16x16 matrix in zigzag pattern
FastLED_NeoMatrix matrix = FastLED_NeoMatrix(leds, 16, 16,
                                             NEO_MATRIX_TOP + NEO_MATRIX_RIGHT + NEO_MATRIX_ROWS + NEO_MATRIX_ZIGZAG);

// Set current page (0 = cartoon, 1 = pomodoro)
int currentPage = CARTOON_PAGE;

// Set up Joystick Reading
int joystickX = 0;
const int JOYSTICK_THRESHOLD = 800; 

// Colors - using FastLED CRGB instead of matrix.Color
CRGB colorWhite = CRGB(255, 255, 255);
CRGB colorRed = CRGB(255, 0, 0);
CRGB colorGreen = CRGB(0, 255, 0);
CRGB colorOrange = CRGB(255, 165, 0);
CRGB customColor = CRGB(255, 135, 137);

// --- Keypad Setup ---
const byte ROWS = 4;
const byte COLS = 4;
char keys[ROWS][COLS] = {
  { '1', '2', '3', 'A' },
  { '4', '5', '6', 'B' },
  { '7', '8', '9', 'C' },
  { '*', '0', '#', 'D' }
};
byte rowPins[ROWS] = { 9, 8, 7, 6 };
byte colPins[COLS] = { 5, 4, 3, 2 };
Keypad keypad = Keypad(makeKeymap(keys), rowPins, colPins, ROWS, COLS);

void configureMatrixText() {
  matrix.setTextWrap(false);
  matrix.setTextColor(matrix.Color(customColor.r, customColor.g, customColor.b));
  matrix.setTextSize(1);
}

// ---------------------------------
// Frame bitmaps in PROGMEM
// ---------------------------------
// Frame definitions here (unchanged - skipped as requested)
const uint32_t DigDug01[NUM_LEDS] PROGMEM = {
  0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 
  0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0xcccccc, 0xcccccc, 0xcccccc, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 
  0x000000, 0x000000, 0x000000, 0xcccccc, 0xcccccc, 0xcccccc, 0xcccccc, 0xcccccc, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 
  0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0xcccccc, 0xcccccc, 0xcccccc, 0xcccccc, 0xcccccc, 0xcccccc, 0xcccccc, 0xcccccc, 0x000000, 0x000000, 
  0x000000, 0xcccccc, 0xcccccc, 0xcccccc, 0xcccccc, 0xcccccc, 0xcccccc, 0xcccccc, 0xcccccc, 0xcccccc, 0xcccccc, 0xcccccc, 0x000000, 0x000000, 0x000000, 0x000000, 
  0x000000, 0x000000, 0x000000, 0x000000, 0x0066cc, 0x000000, 0x0066cc, 0x000000, 0x0066cc, 0x0066cc, 0x0066cc, 0x0066cc, 0xcccccc, 0xcccccc, 0xcccccc, 0x000000, 
  0x000000, 0xcccccc, 0xcccccc, 0xcccccc, 0x0066cc, 0x0066cc, 0x0066cc, 0x0066cc, 0x000000, 0x0066cc, 0x000000, 0x0066cc, 0x000000, 0x000000, 0x000000, 0x000000, 
  0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x0066cc, 0x0066cc, 0x0066cc, 0x0066cc, 0x0066cc, 0x0066cc, 0xcccccc, 0xcccccc, 0xcccccc, 0xcccccc, 0x000000, 
  0x000000, 0x000000, 0x000000, 0x0066cc, 0x0066cc, 0xcccccc, 0xcccccc, 0xcccccc, 0xcccccc, 0xcccccc, 0x000000, 0x000000, 0xff0000, 0x000000, 0x000000, 0x000000, 
  0x000000, 0x000000, 0xff0000, 0xff0000, 0x000000, 0xcccccc, 0xcccccc, 0xcccccc, 0xcccccc, 0xcccccc, 0xcccccc, 0x0066cc, 0x0066cc, 0xcccccc, 0x000000, 0x000000, 
  0x000000, 0xff0000, 0xff0000, 0xff0000, 0x0066cc, 0x0066cc, 0x0066cc, 0x0066cc, 0xff0000, 0xff0000, 0xff0000, 0xff0000, 0xff0000, 0xff0000, 0xff0000, 0x000000, 
  0x000000, 0x000000, 0xff0000, 0xff0000, 0x000000, 0xcccccc, 0xcccccc, 0xcccccc, 0x0066cc, 0x0066cc, 0x0066cc, 0xcccccc, 0xcccccc, 0x000000, 0x000000, 0x000000,  
  0x000000, 0x000000, 0xcccccc, 0xcccccc, 0xcccccc, 0xcccccc, 0xcccccc, 0xcccccc, 0xcccccc, 0xcccccc, 0x000000, 0x000000, 0xff0000, 0x000000, 0x000000, 0x000000, 
  0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0xcccccc, 0xcccccc, 0x000000, 0x000000, 0x000000, 0xcccccc, 0xcccccc, 0x000000, 0x000000, 
  0x000000, 0x000000, 0xcccccc, 0xcccccc, 0xcccccc, 0xcccccc, 0x000000, 0xcccccc, 0xcccccc, 0xcccccc, 0xcccccc, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 
  0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000
};  
const uint32_t DigDug02[NUM_LEDS] PROGMEM = {
  0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000,
  0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0xcccccc, 0xcccccc, 0xcccccc, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000,
  0x000000, 0x000000, 0x000000, 0xcccccc, 0xcccccc, 0xcccccc, 0xcccccc, 0xcccccc, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000,
  0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0xcccccc, 0xcccccc, 0xcccccc, 0xcccccc, 0xcccccc, 0xcccccc, 0xcccccc, 0xcccccc, 0x000000, 0x000000,
  0x000000, 0xcccccc, 0xcccccc, 0xcccccc, 0xcccccc, 0xcccccc, 0xcccccc, 0xcccccc, 0xcccccc, 0xcccccc, 0xcccccc, 0xcccccc, 0x000000, 0x000000, 0x000000, 0x000000,
  0x000000, 0x000000, 0x000000, 0x000000, 0x0066cc, 0x000000, 0x0066cc, 0x000000, 0x0066cc, 0x0066cc, 0x0066cc, 0x0066cc, 0xcccccc, 0xcccccc, 0xcccccc, 0x000000,
  0x000000, 0xcccccc, 0xcccccc, 0xcccccc, 0x0066cc, 0x0066cc, 0x0066cc, 0x0066cc, 0x000000, 0x0066cc, 0x000000, 0x0066cc, 0x000000, 0x000000, 0x000000, 0x000000,
  0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x0066cc, 0x0066cc, 0x0066cc, 0x0066cc, 0x0066cc, 0x0066cc, 0xcccccc, 0xcccccc, 0xcccccc, 0xcccccc, 0x000000,
  0x000000, 0x000000, 0x000000, 0x0066cc, 0x0066cc, 0xcccccc, 0xcccccc, 0xcccccc, 0xcccccc, 0xcccccc, 0x000000, 0x000000, 0xff0000, 0x000000, 0x000000, 0x000000,
  0x000000, 0x000000, 0xff0000, 0xff0000, 0x000000, 0x000000, 0x000000, 0xcccccc, 0xcccccc, 0xcccccc, 0xcccccc, 0x0066cc, 0x0066cc, 0xcccccc, 0x000000, 0x000000,
  0x000000, 0xff0000, 0xff0000, 0xff0000, 0x0066cc, 0x0066cc, 0x0066cc, 0x0066cc, 0xff0000, 0xff0000, 0xff0000, 0xff0000, 0xff0000, 0xff0000, 0xff0000, 0x000000,
  0x000000, 0x000000, 0xff0000, 0xff0000, 0x000000, 0x000000, 0x000000, 0xcccccc, 0x0066cc, 0x0066cc, 0x0066cc, 0xcccccc, 0xcccccc, 0xcccccc, 0x000000, 0x000000,
  0x000000, 0x000000, 0x000000, 0xcccccc, 0xcccccc, 0xcccccc, 0xcccccc, 0xcccccc, 0x000000, 0x000000, 0x000000, 0x000000, 0xff0000, 0x000000, 0x000000, 0x000000,
  0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0xcccccc, 0xcccccc, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000,
  0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0xcccccc, 0xcccccc, 0xcccccc, 0xcccccc, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000,
  0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000
};  // Placeholder
const uint32_t Qbert01[NUM_LEDS] PROGMEM = {
  0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000,
  0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000,
  0x000000, 0x000000, 0x000000, 0x000000, 0xff6600, 0xff6600, 0xff6600, 0xff6600, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000,
  0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0xff0033, 0xff0033, 0xff0033, 0xff0033, 0xff0033, 0xff6600, 0xff6600, 0xff6600, 0x000000, 0x000000,
  0x000000, 0xff0033, 0xff0033, 0xff6600, 0xff0033, 0xffffcc, 0xffffcc, 0xff0033, 0xffffcc, 0xffffcc, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000,
  0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0xff0033, 0x000000, 0x000000, 0xff0033, 0xff6600, 0xff6600, 0xff0033, 0xff0033,
  0xff0033, 0xff0033, 0xff0033, 0xff6600, 0xff0033, 0xff0033, 0xff0033, 0xff0033, 0xff0033, 0xff0033, 0xff6600, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000,
  0x000000, 0x000000, 0x000000, 0xff6600, 0xff6600, 0xff6600, 0xff6600, 0xff6600, 0xff6600, 0xff0033, 0xff0033, 0xff6600, 0xff6600, 0xff6600, 0xff0033, 0xff0033,
  0xff0033, 0xff0033, 0xff0033, 0xff6600, 0xff6600, 0xff6600, 0xff6600, 0xff6600, 0xff6600, 0xff6600, 0xff6600, 0xff6600, 0xff6600, 0xff6600, 0x000000, 0x000000,
  0x000000, 0xff6600, 0xff6600, 0xff6600, 0xff0033, 0xff0033, 0xff0033, 0xff6600, 0xff0033, 0xff6600, 0xff0033, 0xff6600, 0xff0033, 0xff6600, 0xff0033, 0xff0033,
  0x000000, 0xff0033, 0xff0033, 0xff0033, 0xff0033, 0xff0033, 0xff6600, 0xff0033, 0xff0033, 0x000000, 0xff0033, 0xff0033, 0x000033, 0x000033, 0xff6600, 0x000000,
  0x000000, 0xff0033, 0x000033, 0x000033, 0xff0033, 0x000000, 0x000000, 0x000000, 0xff0033, 0xff0033, 0xff0033, 0xff0033, 0xff0033, 0xff0033, 0x000000, 0x000000,
  0x000000, 0x000000, 0x000000, 0xff0033, 0xff0033, 0xff0033, 0xff0033, 0xff0033, 0x000000, 0x000000, 0x000000, 0x000000, 0xff0033, 0xff0033, 0x000000, 0x000000,
  0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0xff0033, 0x000000, 0x000000, 0xff0033, 0x000000, 0x000000, 0x000000, 0x000000,
  0x000000, 0x000000, 0xff6600, 0xff6600, 0xff6600, 0x000000, 0x000000, 0xff0033, 0xff6600, 0xff6600, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000,
  0x000000, 0x000000, 0x000000, 0x000000, 0xff6600, 0xff6600, 0xff0033, 0x000000, 0x000000, 0xff6600, 0xff6600, 0xff6600, 0xff0033, 0x000000, 0x000000, 0x000000
};  
const uint32_t Qbert02[NUM_LEDS] PROGMEM = {
  0x000000, 0x000000, 0x000000, 0x000000, 0xff6600, 0xff6600, 0xff6600, 0xff6600, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000,
  0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0xff0033, 0xff0033, 0xff0033, 0xff0033, 0xff0033, 0xff6600, 0xff6600, 0xff6600, 0x000000, 0x000000,
  0x000000, 0xff0033, 0xff0033, 0xff6600, 0xff0033, 0xffffff, 0xffffff, 0xff0033, 0xffffff, 0xffffff, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000,
  0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0xff0033, 0x000000, 0x000000, 0xff0033, 0xff6600, 0xff6600, 0xff0033, 0x000000,
  0xff0033, 0xff0033, 0xff0033, 0xff6600, 0xff0033, 0x000000, 0x000000, 0xff0033, 0x000000, 0x000000, 0xff6600, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000,
  0x000000, 0x000000, 0x000000, 0xff6600, 0xff6600, 0xff6600, 0xff6600, 0xff6600, 0xff6600, 0xff0033, 0xff0033, 0xff6600, 0xff6600, 0xff6600, 0xff0033, 0xff0033,
  0xff0033, 0xff0033, 0xff0033, 0xff6600, 0xff6600, 0xff6600, 0xff6600, 0xff6600, 0xff6600, 0xff6600, 0xff6600, 0xff6600, 0xff6600, 0xff6600, 0x000000, 0x000000,
  0x000000, 0xff6600, 0xff6600, 0xff6600, 0xff0033, 0xff0033, 0xff0033, 0xff6600, 0xff0033, 0xff6600, 0xff0033, 0xff6600, 0xff0033, 0xff6600, 0xff0033, 0xff0033,
  0x000000, 0xff0033, 0xff0033, 0xff0033, 0xff0033, 0xff0033, 0xff6600, 0xff0033, 0xff0033, 0x000000, 0xff0033, 0xff0033, 0x000000, 0x000000, 0xff6600, 0x000000,
  0x000000, 0xff0033, 0x000000, 0x000000, 0xff0033, 0x000000, 0x000000, 0x000000, 0xff0033, 0xff0033, 0xff0033, 0xff0033, 0xff0033, 0xff0033, 0x000000, 0x000000,
  0x000000, 0x000000, 0x000000, 0xff0033, 0xff0033, 0xff0033, 0xff0033, 0xff0033, 0x000000, 0x000000, 0x000000, 0x000000, 0xff0033, 0xff0033, 0x000000, 0x000000,
  0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0xff0033, 0x000000, 0x000000, 0x000000, 0xff0033, 0x000000, 0x000000, 0x000000,
  0x000000, 0x000000, 0x000000, 0xff0033, 0x000000, 0x000000, 0x000000, 0xff0033, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000,
  0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0xff0033, 0x000000, 0x000000, 0x000000, 0xff0033, 0x000000, 0x000000, 0x000000,
  0x000000, 0x000000, 0xff6600, 0xff6600, 0xff6600, 0x000000, 0x000000, 0xff0033, 0xff6600, 0xff6600, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000,
  0x000000, 0x000000, 0x000000, 0x000000, 0xff6600, 0xff6600, 0xff0033, 0x000000, 0x000000, 0xff6600, 0xff6600, 0xff6600, 0xff0033, 0x000000, 0x000000, 0x000000
};
const uint32_t BombJack01[NUM_LEDS] PROGMEM = {
  0x333366, 0x333366, 0x333366, 0x333366, 0x333366, 0x333366, 0x333366, 0x333366, 0x333366, 0x333366, 0x333366, 0x333366, 0x333366, 0x333366, 0x333366, 0x333366,
  0x333366, 0x333366, 0x333366, 0x0099ff, 0x333366, 0x333366, 0x0099ff, 0x0099ff, 0x0099ff, 0x0099ff, 0x0099ff, 0x333366, 0x333366, 0x0099ff, 0x333366, 0x333366,
  0x333366, 0x333366, 0x0099ff, 0x0099ff, 0x0099ff, 0x0099ff, 0x0099ff, 0x0099ff, 0x0099ff, 0x0099ff, 0x0099ff, 0x0099ff, 0x0099ff, 0x333366, 0x333366, 0x333366,
  0x333366, 0x333366, 0x333366, 0x0099ff, 0x0099ff, 0x0099ff, 0xffffff, 0xffffff, 0x0099ff, 0xffffff, 0xffffff, 0x0099ff, 0x0099ff, 0x0099ff, 0x333366, 0x333366,
  0x333366, 0x333366, 0x333366, 0x0099ff, 0x0099ff, 0xffffff, 0x000000, 0x0099ff, 0x000000, 0xffffff, 0x0099ff, 0x0099ff, 0x333366, 0x333366, 0x333366, 0x333366,
  0x333366, 0x333366, 0x333366, 0x333366, 0x333366, 0x0099ff, 0xffffff, 0x000000, 0x0099ff, 0x000000, 0xffffff, 0x0099ff, 0x333366, 0x333366, 0x333366, 0x333366,
  0x333366, 0x333366, 0x333366, 0x333366, 0x333366, 0xffcc99, 0xffcc99, 0xffcc99, 0xffcc99, 0xffcc99, 0x333366, 0x333366, 0x333366, 0x333366, 0x333366, 0x333366,
  0x333366, 0x333366, 0x333366, 0x333366, 0x333366, 0xffffff, 0xffcc99, 0xffcc99, 0xffcc99, 0xffcc99, 0xffcc99, 0xffffff, 0x333366, 0x333366, 0x333366, 0x333366,
  0x333366, 0x333366, 0x333366, 0xff0000, 0xff0000, 0xffffff, 0xffffff, 0xffffff, 0xffffff, 0xffffff, 0xff0000, 0xff0000, 0x333366, 0x333366, 0x333366, 0x333366,
  0x333366, 0x333366, 0x333366, 0xff0000, 0xff0000, 0xff0000, 0xff0000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0xff0000, 0xff0000, 0xff0000, 0x333366, 0x333366,
  0x333366, 0x000000, 0x000000, 0xff0000, 0xff0000, 0xff0000, 0xff0000, 0xff0000, 0xff0000, 0xff0000, 0xff0000, 0xff0000, 0x000000, 0x000000, 0x333366, 0x333366,
  0x333366, 0x333366, 0x000000, 0x000000, 0xffffff, 0x0099ff, 0x0099ff, 0x0099ff, 0xffff00, 0x0099ff, 0x0099ff, 0x0099ff, 0xffffff, 0x000000, 0x000000, 0x333366,
  0x333366, 0xffffff, 0xffffff, 0xffffff, 0xff0000, 0xff0000, 0xff0000, 0xff0000, 0xff0000, 0xff0000, 0xff0000, 0xffffff, 0xffffff, 0xffffff, 0x333366, 0x333366,
  0x333366, 0x333366, 0xffffff, 0xffffff, 0xffffff, 0xff0000, 0xff0000, 0xff0000, 0xff0000, 0xff0000, 0xff0000, 0xff0000, 0xffffff, 0xffffff, 0xffffff, 0x333366,
  0x333366, 0x333366, 0xffffff, 0xffffff, 0xffffff, 0xff0000, 0xff0000, 0xffffff, 0xff0000, 0xff0000, 0xffffff, 0xffffff, 0xffffff, 0xffffff, 0x333366, 0x333366,
  0x333366, 0x333366, 0x333366, 0x333366, 0x333366, 0x000000, 0x000000, 0x000000, 0x333366, 0x000000, 0x000000, 0x000000, 0x333366, 0x333366, 0x333366, 0x333366
}; 
const uint32_t BombJack02[NUM_LEDS] PROGMEM = {
  0x333366, 0x333366, 0x333366, 0x333366, 0x333366, 0x333366, 0x333366, 0x333366, 0x333366, 0x333366, 0x333366, 0x333366, 0x333366, 0x333366, 0x333366, 0x333366,
  0x333366, 0x333366, 0x333366, 0x0099ff, 0x333366, 0x333366, 0x0099ff, 0x0099ff, 0x0099ff, 0x0099ff, 0x0099ff, 0x333366, 0x333366, 0x0099ff, 0x333366, 0x333366,
  0x333366, 0x333366, 0x0099ff, 0x0099ff, 0x0099ff, 0x0099ff, 0x0099ff, 0x0099ff, 0x0099ff, 0x0099ff, 0x0099ff, 0x0099ff, 0x0099ff, 0x333366, 0x333366, 0x333366,
  0x333366, 0x333366, 0x333366, 0x0099ff, 0x0099ff, 0x0099ff, 0xffffff, 0x000000, 0x0099ff, 0x000000, 0xffffff, 0x0099ff, 0x0099ff, 0x0099ff, 0x333366, 0x333366,
  0x333366, 0x333366, 0x333366, 0x0099ff, 0x0099ff, 0xffffff, 0x000000, 0x0099ff, 0x000000, 0xffffff, 0x0099ff, 0x0099ff, 0x333366, 0x333366, 0x333366, 0x333366,
  0x333366, 0x333366, 0x000000, 0x000000, 0x333366, 0x0099ff, 0xffffff, 0xffffff, 0xffcc99, 0xffffff, 0xffffff, 0x0099ff, 0x333366, 0x000000, 0x000000, 0x333366,
  0x333366, 0x000000, 0x000000, 0xff0000, 0xffcc99, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0xffcc99, 0xff0000, 0x000000, 0x000000, 0x333366, 0x333366,
  0x333366, 0x333366, 0x333366, 0xff0000, 0xff0000, 0xffffff, 0xffcc99, 0xffcc99, 0xffcc99, 0xffcc99, 0xffcc99, 0xffffff, 0xff0000, 0xff0000, 0x333366, 0x333366,
  0x333366, 0x333366, 0x333366, 0xff0000, 0xff0000, 0xffffff, 0xffffff, 0xffffff, 0xffffff, 0xffffff, 0xff0000, 0xff0000, 0xffffff, 0x333366, 0x333366, 0x333366,
  0x333366, 0x333366, 0xffffff, 0xffffff, 0xffffff, 0xff0000, 0xff0000, 0x000000, 0xff0000, 0x000000, 0xff0000, 0xff0000, 0xffffff, 0xffffff, 0x333366, 0x333366,
  0x333366, 0x333366, 0xffffff, 0xffffff, 0xff0000, 0xff0000, 0xff0000, 0xff0000, 0xff0000, 0xff0000, 0xff0000, 0xffffff, 0xffffff, 0xffffff, 0x333366, 0x333366,
  0x333366, 0x333366, 0xffffff, 0xffffff, 0xffffff, 0x0099ff, 0x0099ff, 0x0099ff, 0xffff00, 0x0099ff, 0x0099ff, 0x0099ff, 0xffffff, 0xffffff, 0xffffff, 0x333366,
  0x333366, 0xffffff, 0xffffff, 0xffffff, 0xff0000, 0xff0000, 0xff0000, 0xff0000, 0xff0000, 0xff0000, 0xff0000, 0xffffff, 0xffffff, 0xffffff, 0xffffff, 0x333366,
  0x333366, 0xffffff, 0xffffff, 0xffffff, 0xffffff, 0xff0000, 0xff0000, 0xff0000, 0xff0000, 0xff0000, 0xff0000, 0xff0000, 0xffffff, 0xffffff, 0xffffff, 0xffffff,
  0x333366, 0x333366, 0x333366, 0xffffff, 0xffffff, 0xff0000, 0xff0000, 0xffffff, 0xff0000, 0xff0000, 0xffffff, 0x333366, 0xffffff, 0xffffff, 0x333366, 0x333366,
  0x333366, 0x333366, 0x333366, 0x333366, 0x333366, 0x000000, 0x000000, 0x000000, 0x333366, 0x000000, 0x000000, 0x000000, 0x333366, 0x333366, 0x333366, 0x333366
};  

// --- Pomodoro State Management ---
enum State { SETTING,
             COUNTDOWN,
             REST };
State state = SETTING;

String input = "";
int minutes = 0;
int seconds = 0;
unsigned long lastMillis = 0;

int pomodoroCount = 0;
int studyDuration = 0;
int shortRestDuration = 0;
int longRestDuration = 0;

bool settingsComplete = false;
int settingStage = 0;  // Track which setting we're configuring: 0=none, 1=study, 2=short rest, 3=long rest

// ==== FUNCTIONS ====

// Draw a frame from PROGMEM to the LED array - Updated for FastLED
// Alternative implementation if above doesn't work
void drawFrame(const uint32_t *bitmap) {
  FastLED.clear();
  for (int y = 0; y < 16; y++) {
    for (int x = 0; x < 16; x++) {
      // if this is a "zig" (odd) row, read from the opposite x
      int xRead = (y & 1) ? (15 - x) : x;
      int bitmapIndex = y * 16 + xRead;

      uint32_t color = pgm_read_dword(&bitmap[bitmapIndex]);
      uint8_t r = (color >> 16) & 0xFF;
      uint8_t g = (color >> 8)  & 0xFF;
      uint8_t b =  color        & 0xFF;

      leds[ matrix.XY(x, y) ] = CRGB(r, g, b);
    }
  }
  FastLED.show();
}

// Animate between two frames
void playAnimation(const uint32_t *frame1, const uint32_t *frame2, uint16_t delayMs) {
  static unsigned long lastChange = 0;
  static bool frameToggle = false;

  if (millis() - lastChange > delayMs) {
    frameToggle = !frameToggle;
    lastChange = millis();

    if (frameToggle) {
      drawFrame(frame1);
    } else {
      drawFrame(frame2);
    }
  }
}

// Check joystick for page switching
void checkJoystick() {
  static unsigned long lastSwitch = 0;
  joystickX = analogRead(JOY_X_PIN);

  // Only switch if joystick is pushed far enough and debounce time has passed
  if (joystickX > JOYSTICK_THRESHOLD && (millis() - lastSwitch > 500)) {
    lastSwitch = millis();
    currentPage = !currentPage;  // Toggle between pages

    Serial.print(F("Switched to "));
    Serial.println(currentPage ? "Pomodoro" : "Cartoon");

    // Clear display when switching pages
    matrix.fillScreen(0);
    FastLED.show();

    // If switching to pomodoro for first time, show initial message
    if (currentPage == POMODORO_PAGE && state == SETTING && settingStage == 0) {
      settingStage = 1;  // Start with study duration input
      matrix.fillScreen(0);
      matrix.setCursor(3, 4);
      matrix.print("S?");
      FastLED.show();
      Serial.println(F("Enter Study duration:"));
    }
  }
}

// Initial welcome message
void showSplash() {
  matrix.fillScreen(0);
  matrix.setCursor(3, 4);
  matrix.print("HI");
  FastLED.show();
}

// Draw Pomodoro indicators showing count and state
void drawIndicators(bool isStudy) {
  // Draw pomodoro count indicators (0-4)
  for (int i = 0; i < 4; i++) {
    // Use direct access to leds array
    leds[matrix.XY(0, i)] = (i < pomodoroCount) ? colorWhite : CRGB(0, 0, 0);
  }

  // Draw current state indicator
  if (isStudy) {
    leds[matrix.XY(15, 0)] = colorRed;  // Study = red
  } else {
    leds[matrix.XY(15, 0)] = (pomodoroCount == 4) ? colorOrange : colorGreen;
  }
}

void showTimeSplit(int min, int sec, bool isStudy) {
  matrix.fillScreen(0);
  drawIndicators(isStudy);

  // Create a clearer text color based on state
  CRGB timeColor = isStudy ? colorRed : colorGreen;
  if (!isStudy && pomodoroCount == 4) timeColor = colorOrange;

  // Set text color before printing
  matrix.setTextColor(matrix.Color(timeColor.r, timeColor.g, timeColor.b));

  // Show minutes (top row)
  matrix.setCursor(3, 1);
  if (min < 10) matrix.print("0");
  matrix.print(min);

  // Show seconds (bottom row)
  matrix.setCursor(3, 8);
  if (sec < 10) matrix.print("0");
  matrix.print(sec);

  // Ensure matrix is updated
  FastLED.show();
}

// Sound the buzzer to indicate session change
void buzzerBeep() {
  digitalWrite(BUZZER_PIN, LOW);  // Active LOW buzzer
  delay(300);
  digitalWrite(BUZZER_PIN, HIGH);
  delay(300);
  digitalWrite(BUZZER_PIN, LOW);
  delay(300);
  digitalWrite(BUZZER_PIN, HIGH);
}

// Reset all pomodoro settings to start fresh
void resetSettings() {
  studyDuration = 0;
  shortRestDuration = 0;
  longRestDuration = 0;
  pomodoroCount = 0;
  state = SETTING;
  settingsComplete = false;
  settingStage = 0;
  input = "";
  matrix.setTextColor(matrix.Color(customColor.r, customColor.g, customColor.b));

  Serial.println("Settings reset.");
  showSplash();
}

// === CARTOON MODE ===
void runCartoon() {
  char key = keypad.getKey();

  if (key) {
    Serial.print(F("Key pressed: "));
    Serial.println(key);

    switch (key) {
      case '1':
        while (!keypad.getKey()) {  // Exit on any key press
          playAnimation(DigDug01, DigDug02, 250);
        }
        break;
      case '2':
        while (!keypad.getKey()) {
          playAnimation(Qbert01, Qbert02, 500);
        }
        break;
      case '3':
        while (!keypad.getKey()) {
          playAnimation(BombJack01, BombJack02, 400);
        }
        break;
      default:
        // Flash feedback - using FastLED
        fill_solid(leds, NUM_LEDS, CRGB(255, 0, 0));  // Red flash
        FastLED.show();
        delay(200);
        fill_solid(leds, NUM_LEDS, CRGB(0, 0, 0));
        FastLED.show();
        break;
    }
  }
}

// === POMODORO MODE ===
void runPomodoro() {
  // Handle settings input phase
  if (state == SETTING) {
    char key = keypad.getKey();

    // Process numeric input
    if (key && isDigit(key)) {
      input += key;
      Serial.print(F("Entered: "));
      Serial.println(input);

      // Show input on matrix in real-time
      matrix.fillScreen(0);
      matrix.setCursor(2, 4);
      matrix.print(input);
      FastLED.show();
    }

    // Process "enter" action (joystick button press)
    if (digitalRead(JOY_BUTTON_PIN) == LOW) {
      delay(200);  // Debounce
      while (digitalRead(JOY_BUTTON_PIN) == LOW)
        ;  // Wait for button release

      if (!settingsComplete) {
        // Process based on which setting we're currently configuring
        switch (settingStage) {
          case 1:  // Study duration
            if (input.length() > 0) {
              studyDuration = input.toInt();
              Serial.print(F("Study duration set to: "));
              Serial.println(studyDuration);
              input = "";
              settingStage = 2;

              // Show prompt for short rest
              matrix.fillScreen(0);
              matrix.setCursor(2, 4);
              matrix.print("SR");
              FastLED.show();
              Serial.println(F("Enter Short Rest duration:"));
            }
            break;

          case 2:  // Short rest duration
            if (input.length() > 0) {
              shortRestDuration = input.toInt();
              Serial.print(F("Short rest duration set to: "));
              Serial.println(shortRestDuration);
              input = "";
              settingStage = 3;

              // Show prompt for long rest
              matrix.fillScreen(0);
              matrix.setCursor(2, 4);
              matrix.print("LR");
              FastLED.show();
              Serial.println(F("Enter Long Rest duration:"));
            }
            break;

          case 3:  // Long rest duration
            if (input.length() > 0) {
              longRestDuration = input.toInt();
              Serial.print(F("Long rest duration set to: "));
              Serial.println(longRestDuration);
              settingsComplete = true;
              input = "";

              // Show ready message
              matrix.fillScreen(0);
              matrix.setCursor(0, 4);
              matrix.print("Ready");
              FastLED.show();
              delay(1000);
            }
            break;
        }

        // Start timer if all settings are complete
        if (settingsComplete) {
          state = COUNTDOWN;
          minutes = studyDuration;
          seconds = 0;
          lastMillis = millis();
          Serial.println(F("Pomodoro started!"));
          showTimeSplit(minutes, seconds, true);
        }
      }
    }

    // Allow settings reset
    if (key == '#') {
      resetSettings();
      settingStage = 1;
      matrix.fillScreen(0);
      matrix.setCursor(3, 4);
      matrix.print("S?");
      FastLED.show();
      Serial.println(F("Enter Study duration:"));
    }
  }

  // Handle countdown and rest phases
  if (state == COUNTDOWN || state == REST) {
    if (millis() - lastMillis >= 1000) {
      lastMillis = millis();

      // Handle timer completion
      if (minutes == 0 && seconds == 0) {
        buzzerBeep();

        if (state == COUNTDOWN) {
          // Study session complete
          pomodoroCount++;
          state = REST;

          if (pomodoroCount == 4) {
            // Long rest after 4 pomodoros
            minutes = longRestDuration;
            seconds = 0;
            Serial.println(F("Long rest session started."));
          } else {
            // Short rest between pomodoros
            minutes = shortRestDuration;
            seconds = 0;
            Serial.println(F("Short rest session started."));
          }
        } else if (state == REST) {
          if (pomodoroCount < 4) {
            // Start next study session
            minutes = studyDuration;
            seconds = 0;
            state = COUNTDOWN;
            Serial.println(F("Next study session started."));
          } else {
            // Completed all 4 pomodoros
            Serial.println(F("All pomodoro sessions completed!"));

            // Show congratulations before reset
            matrix.fillScreen(0);
            matrix.setCursor(1, 4);
            matrix.print("DONE!");
            FastLED.show();
            delay(3000);

            resetSettings();
            settingStage = 1;
            matrix.fillScreen(0);
            matrix.setCursor(3, 4);
            matrix.print("S?");
            FastLED.show();
            Serial.println(F("Enter Study duration:"));
            return;
          }
        }
      }

      // Update timer
      if (seconds == 0) {
        minutes--;
        seconds = 59;
      } else {
        seconds--;
      }

      // Update display
      showTimeSplit(minutes, seconds, state == COUNTDOWN);
    }

    // Check for manual reset
    char key = keypad.getKey();
    if (key == '#') {
      resetSettings();
      settingStage = 1;
      matrix.fillScreen(0);
      matrix.setCursor(3, 4);
      matrix.print("S?");
      FastLED.show();
      Serial.println(F("Enter Study duration:"));
    }
  }
}

void setup() {
  Serial.begin(9600);

  // Initialize FastLED
  FastLED.addLeds<WS2812B, PIN_MATRIX, GRB>(leds, NUM_LEDS);
  FastLED.setBrightness(20);
  FastLED.clear();

  // Initialize matrix
  matrix.begin();
  matrix.setTextWrap(false);
  matrix.setTextColor(matrix.Color(customColor.r, customColor.g, customColor.b));

  // Set up pins
  pinMode(BUZZER_PIN, OUTPUT);
  pinMode(JOY_BUTTON_PIN, INPUT_PULLUP);

  digitalWrite(BUZZER_PIN, HIGH);  // Buzzer off initially

  delay(100);  // Give the matrix time to initialize

  // Test pattern to ensure matrix is working
  fill_solid(leds, NUM_LEDS, CRGB(50, 0, 0));  // Dim red
  FastLED.show();
  delay(500);

  fill_solid(leds, NUM_LEDS, CRGB(0, 0, 0));  // Clear
  FastLED.show();
  delay(500);

  showSplash();
  delay(1000);

  Serial.println(F("16x16 LED Matrix - Cartoon & Pomodoro Timer"));
  Serial.println(F("Press 1-3 in Cartoon mode to show animations"));
  Serial.println(F("Move joystick right to switch between modes"));
}

void loop() {
  checkJoystick();

  if (currentPage == CARTOON_PAGE) {
    runCartoon();
  } else if (currentPage == POMODORO_PAGE) {
    runPomodoro();
  }
}